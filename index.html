<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Happy Birthday Asia</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=Dancing+Script:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;0,900;1,400&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #06060e;
  --neon-pink: #ff2d95;
  --neon-purple: #b44dff;
  --neon-blue: #00d4ff;
  --neon-gold: #ffb800;
  --neon-green: #00ff88;
  --neon-cyan: #00fff7;
  --text: #f0ede8;
  --text-dim: rgba(255,255,255,0.3);
}

html { scroll-behavior: smooth; }

body {
  font-family: 'Inter', sans-serif;
  background: var(--bg);
  color: var(--text);
  overflow-x: hidden;
  -webkit-font-smoothing: antialiased;
}

canvas {
  position: fixed;
  inset: 0;
  z-index: 0;
  pointer-events: none;
}

/* ══════════════════════════════════
   START OVERLAY
   ══════════════════════════════════ */
.start-overlay {
  position: fixed;
  inset: 0;
  z-index: 100;
  background: var(--bg);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: opacity 0.8s ease, transform 0.8s ease;
}

.start-overlay.dissolve {
  opacity: 0;
  transform: scale(1.1);
  pointer-events: none;
}

#particleCanvas {
  position: absolute;
  inset: 0;
  z-index: 0;
}

.start-content {
  position: relative;
  z-index: 2;
  text-align: center;
}

.halo {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 300px;
  height: 300px;
  transform: translate(-50%, -50%);
  border-radius: 50%;
  background: radial-gradient(circle, rgba(180,77,255,0.15) 0%, transparent 70%);
  animation: haloPulse 3s ease-in-out infinite;
  pointer-events: none;
}

@keyframes haloPulse {
  0%, 100% { transform: translate(-50%,-50%) scale(1); opacity: 0.6; }
  50% { transform: translate(-50%,-50%) scale(1.3); opacity: 1; }
}

.start-sub {
  font-size: 0.8rem;
  letter-spacing: 5px;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 0.5rem;
  opacity: 0;
  animation: fadeUp 0.8s ease 0.3s forwards;
}

.start-name {
  font-family: 'Dancing Script', cursive;
  font-size: clamp(4rem, 14vw, 8rem);
  font-weight: 700;
  color: #fff;
  text-shadow:
    0 0 10px var(--neon-purple),
    0 0 30px var(--neon-purple),
    0 0 60px var(--neon-pink),
    0 0 100px var(--neon-pink);
  animation: neonPulse 2.5s ease-in-out infinite, fadeUp 1s ease 0.6s forwards;
  opacity: 0;
  margin-bottom: 2rem;
}

@keyframes neonPulse {
  0%, 100% {
    text-shadow:
      0 0 10px var(--neon-purple),
      0 0 30px var(--neon-purple),
      0 0 60px var(--neon-pink),
      0 0 100px var(--neon-pink);
  }
  50% {
    text-shadow:
      0 0 5px var(--neon-purple),
      0 0 15px var(--neon-purple),
      0 0 30px var(--neon-pink),
      0 0 50px var(--neon-pink);
  }
}

.start-btn {
  padding: 16px 44px;
  background: transparent;
  border: 2px solid var(--neon-purple);
  border-radius: 50px;
  color: #fff;
  font-family: inherit;
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 3px;
  text-transform: uppercase;
  cursor: pointer;
  position: relative;
  opacity: 0;
  animation: fadeUp 0.8s ease 1s forwards;
  transition: all 0.3s;
  box-shadow:
    0 0 15px rgba(180,77,255,0.3),
    inset 0 0 15px rgba(180,77,255,0.1);
}

.start-btn:hover {
  background: rgba(180,77,255,0.15);
  box-shadow:
    0 0 30px rgba(180,77,255,0.5),
    0 0 60px rgba(180,77,255,0.2),
    inset 0 0 20px rgba(180,77,255,0.15);
  transform: scale(1.05);
}

@keyframes fadeUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ══════════════════════════════════
   PAGE — CAKE
   ══════════════════════════════════ */
.page { position: relative; z-index: 1; }

.page-cake {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

/* Balloons */
#balloonContainer {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 2;
  overflow: hidden;
}

.balloon {
  position: absolute;
  bottom: -160px;
  opacity: 0;
}

.balloon-body {
  width: 44px;
  height: 56px;
  border-radius: 50% 50% 50% 50% / 40% 40% 60% 60%;
  border: 2px solid currentColor;
  background: transparent;
  position: relative;
  box-shadow:
    0 0 8px currentColor,
    inset 0 0 8px rgba(255,255,255,0.05);
}

.balloon-body::after {
  content: '';
  position: absolute;
  bottom: -5px;
  left: 50%;
  transform: translateX(-50%);
  border-left: 4px solid transparent;
  border-right: 4px solid transparent;
  border-top: 7px solid currentColor;
  filter: drop-shadow(0 0 4px currentColor);
}

.balloon-string {
  width: 1px;
  height: 40px;
  background: linear-gradient(180deg, currentColor, transparent);
  margin: 0 auto;
  opacity: 0.4;
}

@keyframes floatUp {
  0% { bottom: -160px; opacity: 0; transform: translateX(0) rotate(0deg); }
  8% { opacity: 0.9; }
  25% { transform: translateX(25px) rotate(4deg); }
  50% { transform: translateX(-20px) rotate(-3deg); }
  75% { transform: translateX(15px) rotate(2deg); }
  90% { opacity: 0.9; }
  100% { bottom: 110vh; opacity: 0; transform: translateX(-10px) rotate(-1deg); }
}

/* Title */
.hb-title {
  font-family: 'Playfair Display', serif;
  font-size: clamp(2rem, 6vw, 4rem);
  font-weight: 900;
  color: #fff;
  text-shadow:
    0 0 10px var(--neon-gold),
    0 0 30px var(--neon-gold),
    0 0 60px rgba(255,184,0,0.4);
  opacity: 0;
  transform: translateY(-25px);
  transition: opacity 1s ease, transform 1s ease;
  z-index: 5;
  position: relative;
  letter-spacing: 2px;
}

.hb-title.visible { opacity: 1; transform: translateY(0); }

.hb-name {
  font-family: 'Dancing Script', cursive;
  font-size: clamp(3rem, 10vw, 5.5rem);
  font-weight: 700;
  color: #fff;
  text-shadow:
    0 0 10px var(--neon-pink),
    0 0 30px var(--neon-pink),
    0 0 60px var(--neon-purple),
    0 0 90px var(--neon-purple);
  opacity: 0;
  transform: translateY(-20px);
  transition: opacity 1s ease 0.3s, transform 1s ease 0.3s;
  z-index: 5;
  position: relative;
  margin-bottom: 1.5rem;
  animation: none;
}

.hb-name.visible {
  opacity: 1;
  transform: translateY(0);
  animation: neonCycle 6s ease-in-out infinite;
}

@keyframes neonCycle {
  0%, 100% {
    text-shadow: 0 0 10px var(--neon-pink), 0 0 30px var(--neon-pink), 0 0 60px var(--neon-purple), 0 0 90px var(--neon-purple);
  }
  25% {
    text-shadow: 0 0 10px var(--neon-blue), 0 0 30px var(--neon-blue), 0 0 60px var(--neon-cyan), 0 0 90px var(--neon-cyan);
  }
  50% {
    text-shadow: 0 0 10px var(--neon-gold), 0 0 30px var(--neon-gold), 0 0 60px var(--neon-pink), 0 0 90px var(--neon-pink);
  }
  75% {
    text-shadow: 0 0 10px var(--neon-purple), 0 0 30px var(--neon-purple), 0 0 60px var(--neon-blue), 0 0 90px var(--neon-blue);
  }
}

/* ══════════════════════════════════
   NEON CAKE
   ══════════════════════════════════ */
.cake-wrapper {
  position: relative;
  z-index: 5;
  margin-bottom: 2.5rem;
}

.cake {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Plate */
.plate {
  width: 240px;
  height: 14px;
  border: 2px solid rgba(255,255,255,0.25);
  border-radius: 50%;
  background: transparent;
  box-shadow:
    0 0 10px rgba(255,255,255,0.15),
    0 0 30px rgba(255,255,255,0.05),
    inset 0 0 10px rgba(255,255,255,0.05);
  opacity: 0;
  transform: scale(0.5);
  transition: opacity 0.6s ease, transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.plate.visible { opacity: 1; transform: scale(1); }

/* Layers — neon outlines */
.layer {
  border: 2px solid transparent;
  background: transparent;
  border-radius: 10px 10px 6px 6px;
  opacity: 0;
  transform: translateY(40px) scale(0.7);
  transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
  position: relative;
}

.layer.visible {
  opacity: 1;
  transform: translateY(0) scale(1);
}

.layer.flash {
  filter: brightness(2);
  transition: filter 0.15s ease;
}

.layer-1 {
  width: 200px;
  height: 55px;
  border-color: var(--neon-pink);
  margin-top: -8px;
  box-shadow:
    0 0 10px var(--neon-pink),
    0 0 25px rgba(255,45,149,0.3),
    inset 0 0 10px rgba(255,45,149,0.1);
}

.layer-2 {
  width: 150px;
  height: 48px;
  border-color: var(--neon-purple);
  margin-top: -4px;
  box-shadow:
    0 0 10px var(--neon-purple),
    0 0 25px rgba(180,77,255,0.3),
    inset 0 0 10px rgba(180,77,255,0.1);
}

.layer-3 {
  width: 105px;
  height: 40px;
  border-color: var(--neon-gold);
  margin-top: -4px;
  box-shadow:
    0 0 10px var(--neon-gold),
    0 0 25px rgba(255,184,0,0.3),
    inset 0 0 10px rgba(255,184,0,0.1);
}

/* Neon drips */
.neon-drip {
  position: absolute;
  bottom: -2px;
  width: 3px;
  border-radius: 0 0 3px 3px;
  opacity: 0;
  transform: scaleY(0);
  transform-origin: top;
  transition: opacity 0.4s ease, transform 0.7s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.neon-drip.visible { opacity: 1; transform: scaleY(1); }

/* Layer 3 drips (gold) */
.nd-1 { left: 18%; height: 12px; background: var(--neon-gold); box-shadow: 0 0 6px var(--neon-gold); transition-delay: 0.1s; }
.nd-2 { right: 22%; height: 16px; background: var(--neon-gold); box-shadow: 0 0 6px var(--neon-gold); transition-delay: 0.3s; }

/* Layer 2 drips (purple) */
.nd-3 { left: 15%; height: 14px; background: var(--neon-purple); box-shadow: 0 0 6px var(--neon-purple); transition-delay: 0.1s; }
.nd-4 { left: 50%; height: 18px; background: var(--neon-purple); box-shadow: 0 0 6px var(--neon-purple); transition-delay: 0.25s; }
.nd-5 { right: 18%; height: 12px; background: var(--neon-purple); box-shadow: 0 0 6px var(--neon-purple); transition-delay: 0.4s; }

/* Layer 1 drips (pink) */
.nd-6 { left: 10%; height: 16px; background: var(--neon-pink); box-shadow: 0 0 6px var(--neon-pink); transition-delay: 0.1s; }
.nd-7 { left: 35%; height: 22px; background: var(--neon-pink); box-shadow: 0 0 6px var(--neon-pink); transition-delay: 0.2s; }
.nd-8 { left: 60%; height: 14px; background: var(--neon-pink); box-shadow: 0 0 6px var(--neon-pink); transition-delay: 0.35s; }
.nd-9 { right: 10%; height: 18px; background: var(--neon-pink); box-shadow: 0 0 6px var(--neon-pink); transition-delay: 0.45s; }

/* Candles */
.candles {
  display: flex;
  gap: 16px;
  margin-bottom: -4px;
  position: relative;
  z-index: 3;
}

.candle {
  display: flex;
  flex-direction: column;
  align-items: center;
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.5s ease, transform 0.5s ease;
}

.candle.visible { opacity: 1; transform: translateY(0); }

.wick {
  width: 2px;
  height: 8px;
  background: rgba(255,255,255,0.3);
  border-radius: 1px;
}

.c1 .wick { box-shadow: 0 0 4px var(--neon-pink); }
.c2 .wick { box-shadow: 0 0 4px var(--neon-blue); }
.c3 .wick { box-shadow: 0 0 4px var(--neon-green); }

/* Candle body */
.candle::after {
  content: '';
  width: 8px;
  height: 26px;
  border-radius: 3px 3px 1px 1px;
  border: 1.5px solid currentColor;
  background: transparent;
}

.c1 { color: var(--neon-pink); }
.c1::after { box-shadow: 0 0 8px var(--neon-pink), inset 0 0 4px rgba(255,45,149,0.1); }

.c2 { color: var(--neon-blue); }
.c2::after { box-shadow: 0 0 8px var(--neon-blue), inset 0 0 4px rgba(0,212,255,0.1); }

.c3 { color: var(--neon-green); }
.c3::after { box-shadow: 0 0 8px var(--neon-green), inset 0 0 4px rgba(0,255,136,0.1); }

/* Flame */
.flame {
  width: 12px;
  height: 18px;
  position: relative;
  margin-bottom: -2px;
  opacity: 0;
  transform: scale(0);
  transition: opacity 0.4s ease, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.flame.lit {
  opacity: 1;
  transform: scale(1);
  animation: flicker 0.3s ease-in-out infinite alternate;
}

.flame-core {
  width: 100%;
  height: 100%;
  border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
  background: radial-gradient(ellipse at 50% 80%, #fff 0%, #fbbf24 30%, #f97316 60%, transparent 100%);
  box-shadow:
    0 0 8px 3px rgba(251,191,36,0.6),
    0 0 20px 6px rgba(251,191,36,0.3),
    0 0 40px 10px rgba(249,115,22,0.15);
}

@keyframes flicker {
  0% { transform: scale(1) rotate(-3deg); }
  100% { transform: scale(0.88, 1.12) rotate(3deg); }
}

/* Next button */
.next-btn {
  position: relative;
  z-index: 10;
  padding: 16px 40px;
  background: transparent;
  border: 2px solid var(--neon-purple);
  border-radius: 50px;
  color: #fff;
  font-family: inherit;
  font-size: 0.85rem;
  font-weight: 600;
  letter-spacing: 2px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 10px;
  opacity: 0;
  transform: translateY(25px);
  transition: opacity 1.5s ease, transform 1.5s ease, box-shadow 0.3s ease, background 0.3s ease;
  pointer-events: none;
  box-shadow:
    0 0 15px rgba(180,77,255,0.3),
    inset 0 0 15px rgba(180,77,255,0.05);
}

.next-btn.visible {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
  animation: btnGlow 2s ease-in-out infinite;
}

.next-btn:hover {
  background: rgba(180,77,255,0.15);
  box-shadow:
    0 0 30px rgba(180,77,255,0.5),
    0 0 60px rgba(180,77,255,0.2),
    inset 0 0 20px rgba(180,77,255,0.1);
}

@keyframes btnGlow {
  0%, 100% { box-shadow: 0 0 15px rgba(180,77,255,0.3), inset 0 0 15px rgba(180,77,255,0.05); }
  50% { box-shadow: 0 0 25px rgba(180,77,255,0.5), 0 0 50px rgba(180,77,255,0.15), inset 0 0 20px rgba(180,77,255,0.08); }
}

@keyframes pageFadeIn { from { opacity: 0; } to { opacity: 1; } }

/* ══════════════════════════════════
   PAGE — 3D GALLERY
   ══════════════════════════════════ */
.page-gallery {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  z-index: 50;
}

.page-gallery.active { display: flex; animation: pageFadeIn 1.2s ease; }

#galleryRenderer {
  position: absolute;
  inset: 0;
  z-index: 1;
  cursor: grab;
}
#galleryRenderer:active { cursor: grabbing; }
#galleryRenderer canvas { display: block; width: 100%; height: 100%; }

.gallery-hint {
  position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
  z-index: 10; font-size: 0.7rem; letter-spacing: 4px; text-transform: uppercase;
  color: rgba(255,255,255,0.25); text-align: center; pointer-events: none;
  animation: hintFade 5s ease 3s forwards;
}
@keyframes hintFade { 0% { opacity: 1; } 100% { opacity: 0; } }

.gallery-back {
  position: fixed;
  top: 24px;
  left: 24px;
  z-index: 20;
  padding: 10px 20px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 50px;
  background: rgba(6,6,14,0.6);
  backdrop-filter: blur(10px);
  color: rgba(255,255,255,0.4);
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: 500;
  letter-spacing: 2px;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s;
}

.gallery-back:hover {
  border-color: var(--neon-purple);
  color: var(--neon-purple);
  box-shadow: 0 0 15px rgba(180,77,255,0.2);
}

/* Scrollbar */
::-webkit-scrollbar { width: 3px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--neon-purple); border-radius: 2px; }
::selection { background: rgba(180,77,255,0.3); color: #fff; }
  </style>
</head>
<body>

  <!-- ═══ START OVERLAY ═══ -->
  <div class="start-overlay" id="startOverlay">
    <canvas id="particleCanvas"></canvas>
    <div class="start-content">
      <div class="halo"></div>
      <p class="start-sub">a little something for</p>
      <h1 class="start-name">Asia</h1>
      <button class="start-btn" id="startBtn">Tap to Celebrate</button>
    </div>
  </div>

  <!-- ═══ PAGE 1: CAKE ═══ -->
  <section class="page page-cake" id="pageCake">
    <canvas id="starsCanvas"></canvas>
    <div id="balloonContainer"></div>

    <h1 class="hb-title" id="hbTitle">Happy Birthday</h1>
    <p class="hb-name" id="hbName">Asia</p>

    <div class="cake-wrapper" id="cakeWrapper">
      <div class="cake">
        <div class="candles" id="candles">
          <div class="candle c1"><div class="wick"></div><div class="flame" id="flame1"><div class="flame-core"></div></div></div>
          <div class="candle c2"><div class="wick"></div><div class="flame" id="flame2"><div class="flame-core"></div></div></div>
          <div class="candle c3"><div class="wick"></div><div class="flame" id="flame3"><div class="flame-core"></div></div></div>
        </div>
        <div class="layer layer-3" id="layer3">
          <div class="drip neon-drip nd-1"></div>
          <div class="drip neon-drip nd-2"></div>
        </div>
        <div class="layer layer-2" id="layer2">
          <div class="drip neon-drip nd-3"></div>
          <div class="drip neon-drip nd-4"></div>
          <div class="drip neon-drip nd-5"></div>
        </div>
        <div class="layer layer-1" id="layer1">
          <div class="drip neon-drip nd-6"></div>
          <div class="drip neon-drip nd-7"></div>
          <div class="drip neon-drip nd-8"></div>
          <div class="drip neon-drip nd-9"></div>
        </div>
        <div class="plate" id="plate"></div>
      </div>
    </div>

    <button class="next-btn" id="nextBtn">
      <span>See What I Made For You</span>
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
    </button>
    <audio id="birthdayAudio" src="birthday-piano.mp3" loop></audio>
  </section>

  <!-- ═══ PAGE 2: 3D GALLERY ═══ -->
  <section class="page page-gallery" id="pageGallery">
    <canvas id="particleCanvas3" style="position:absolute;inset:0;z-index:0;pointer-events:none;"></canvas>
    <button class="gallery-back" id="galleryBack">&#8249; Back</button>
    <div id="galleryRenderer"></div>
    <p class="gallery-hint" id="galleryHint">swipe to look around &middot; tap a photo</p>
  </section>

  <script>
// ══════════════════════════════════
//  PHOTOS
// ══════════════════════════════════
window.PHOTOS = [
  "photos/631238345_1413865627105763_1098670414832295385_n.jpg",
  "photos/632605426_2743496372651771_5087056815613210159_n.jpg",
  "photos/634555843_1977783543137215_8727257106951131452_n.jpg",
  "photos/634716292_1987974791811645_1033515507445936490_n.jpg",
  "photos/634846621_1489609379369334_1468262594684237586_n.jpg",
  "photos/636680558_1438960177824267_4786415350908794643_n.jpg",
  "photos/637013449_801733399623594_2609924921644433182_n.jpg"
];

// ══════════════════════════════════
//  STARS CANVAS
// ══════════════════════════════════
const starColors = ['#b44dff', '#ff2d95', '#00d4ff', '#ffb800', '#00ff88', '#e879f9', '#00fff7'];

function initStars(id, colored) {
  const c = document.getElementById(id);
  if (!c) return;
  const ctx = c.getContext('2d');
  let stars = [];

  function resize() {
    c.width = window.innerWidth;
    c.height = window.innerHeight;
    stars = [];
    const count = colored
      ? Math.floor((c.width * c.height) / 3500)
      : Math.floor((c.width * c.height) / 4500);
    for (let i = 0; i < count; i++) {
      stars.push({
        x: Math.random() * c.width,
        y: Math.random() * c.height,
        r: colored ? Math.random() * 1.8 + 0.3 : Math.random() * 1.3 + 0.2,
        a: Math.random() * 0.5 + 0.15,
        s: Math.random() * 0.004 + 0.001,
        p: Math.random() * Math.PI * 2,
        color: colored ? starColors[Math.floor(Math.random() * starColors.length)] : null
      });
    }
  }

  function draw(t) {
    ctx.clearRect(0, 0, c.width, c.height);
    for (const s of stars) {
      const tw = Math.sin(t * s.s + s.p) * 0.35 + 0.65;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      if (s.color) {
        ctx.fillStyle = s.color;
        ctx.globalAlpha = s.a * tw;
      } else {
        ctx.fillStyle = `rgba(255,255,255,${s.a * tw})`;
        ctx.shadowBlur = 0;
      }
      ctx.fill();
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    requestAnimationFrame(draw);
  }

  resize();
  requestAnimationFrame(draw);
  window.addEventListener('resize', resize);
}

// ══════════════════════════════════
//  PARTICLE FIELD
// ══════════════════════════════════
const particleColors = ['#b44dff', '#ff2d95', '#00d4ff', '#ffb800', '#00ff88'];

function initParticleField(canvasId, opts) {
  const c = document.getElementById(canvasId);
  if (!c) return;
  const ctx = c.getContext('2d');
  let particles = [];
  const count = (opts && opts.count) || 80;
  const checkStop = opts && opts.stopWhen;
  const lite = opts && opts.lite;

  function resize() {
    c.width = window.innerWidth;
    c.height = window.innerHeight;
    particles = [];
    for (let i = 0; i < count; i++) {
      particles.push({
        x: Math.random() * c.width,
        y: Math.random() * c.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        r: Math.random() * 2 + 0.5,
        color: particleColors[Math.floor(Math.random() * particleColors.length)],
        a: Math.random() * 0.5 + 0.2,
        pulse: Math.random() * Math.PI * 2
      });
    }
  }

  function draw(t) {
    if (checkStop && checkStop()) return;
    ctx.clearRect(0, 0, c.width, c.height);
    for (const p of particles) {
      p.x += p.vx;
      p.y += p.vy;
      if (p.x < 0) p.x = c.width;
      if (p.x > c.width) p.x = 0;
      if (p.y < 0) p.y = c.height;
      if (p.y > c.height) p.y = 0;

      const glow = Math.sin(t * 0.002 + p.pulse) * 0.2 + 0.8;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.a * glow;
      if (!lite) {
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 12;
      }
      ctx.fill();
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    requestAnimationFrame(draw);
  }

  resize();
  requestAnimationFrame(draw);
  window.addEventListener('resize', resize);
}

// Start screen particles (stop when overlay dissolves)
initParticleField('particleCanvas', {
  count: 80,
  stopWhen: () => {
    const el = document.getElementById('startOverlay');
    return !el || el.classList.contains('dissolve');
  }
});

// ══════════════════════════════════
//  BIRTHDAY PIANO MUSIC
// ══════════════════════════════════
const birthdayAudio = document.getElementById('birthdayAudio');

function initAudio() {
  // Unlock audio on mobile — must happen inside user gesture
  if (birthdayAudio) {
    birthdayAudio.play().then(() => { birthdayAudio.pause(); birthdayAudio.currentTime = 0; }).catch(() => {});
  }
}

function playHappyBirthday() {
  if (!birthdayAudio) return;
  birthdayAudio.volume = 0;
  birthdayAudio.play().catch(() => {});
  // Fade in
  let vol = 0;
  const fadeIn = setInterval(() => {
    vol += 0.05;
    if (vol >= 0.8) { vol = 0.8; clearInterval(fadeIn); }
    birthdayAudio.volume = vol;
  }, 60);
}

function fadeOutMusic() {
  if (!birthdayAudio) return;
  let vol = birthdayAudio.volume;
  const fadeOut = setInterval(() => {
    vol -= 0.02;
    if (vol <= 0) { vol = 0; birthdayAudio.pause(); clearInterval(fadeOut); }
    birthdayAudio.volume = vol;
  }, 60);
}



// ══════════════════════════════════
//  NEON BALLOONS
// ══════════════════════════════════
const balloonContainer = document.getElementById('balloonContainer');
const neonColors = ['#ff2d95', '#b44dff', '#00d4ff', '#ffb800', '#00ff88', '#ff6b35', '#e879f9', '#00fff7'];

function launchBalloon() {
  const b = document.createElement('div');
  b.className = 'balloon';
  const color = neonColors[Math.floor(Math.random() * neonColors.length)];
  b.style.color = color;
  b.style.left = (Math.random() * 85 + 5) + '%';

  const size = Math.random() * 16 + 38;
  const body = document.createElement('div');
  body.className = 'balloon-body';
  body.style.width = size + 'px';
  body.style.height = (size * 1.28) + 'px';

  const string = document.createElement('div');
  string.className = 'balloon-string';

  b.appendChild(body);
  b.appendChild(string);
  balloonContainer.appendChild(b);

  const dur = Math.random() * 4000 + 5000;
  b.style.animation = `floatUp ${dur}ms ease-in-out forwards`;
  b.style.animationDelay = (Math.random() * 300) + 'ms';

  setTimeout(() => b.remove(), dur + 500);
}

function launchWave(count, interval) {
  for (let i = 0; i < count; i++) setTimeout(launchBalloon, i * interval);
}

// ══════════════════════════════════
//  CAKE BUILD SEQUENCE
// ══════════════════════════════════
const hbTitle = document.getElementById('hbTitle');
const hbName = document.getElementById('hbName');
const plate = document.getElementById('plate');
const layer1 = document.getElementById('layer1');
const layer2 = document.getElementById('layer2');
const layer3 = document.getElementById('layer3');
const candleEls = document.querySelectorAll('.candle');
const flame1 = document.getElementById('flame1');
const flame2 = document.getElementById('flame2');
const flame3 = document.getElementById('flame3');
const nextBtn = document.getElementById('nextBtn');

function flashLayer(el) {
  el.classList.add('flash');
  setTimeout(() => el.classList.remove('flash'), 200);
}

function runCakeSequence() {
  const seq = [
    [0, () => { hbTitle.classList.add('visible'); }],
    [500, () => { hbName.classList.add('visible'); }],
    [1400, () => { plate.classList.add('visible'); }],
    [2200, () => {
      layer1.classList.add('visible');
      setTimeout(() => flashLayer(layer1), 700);
      launchWave(3, 250);
    }],
    [3200, () => layer1.querySelectorAll('.neon-drip').forEach(d => d.classList.add('visible'))],
    [3600, () => {
      layer2.classList.add('visible');
      setTimeout(() => flashLayer(layer2), 700);
      launchWave(3, 250);
    }],
    [4500, () => layer2.querySelectorAll('.neon-drip').forEach(d => d.classList.add('visible'))],
    [4900, () => {
      layer3.classList.add('visible');
      setTimeout(() => flashLayer(layer3), 700);
      launchWave(4, 200);
    }],
    [5700, () => layer3.querySelectorAll('.neon-drip').forEach(d => d.classList.add('visible'))],
    [6200, () => { candleEls[0].classList.add('visible'); }],
    [6500, () => { candleEls[1].classList.add('visible'); }],
    [6800, () => { candleEls[2].classList.add('visible'); }],
    [7300, () => { flame1.classList.add('lit'); }],
    [7600, () => { flame2.classList.add('lit'); }],
    [7900, () => {
      flame3.classList.add('lit');
      launchWave(10, 150);
    }],
    [8500, () => { playHappyBirthday(); }],
    [11500, () => { nextBtn.classList.add('visible'); }],
  ];

  seq.forEach(([ms, fn]) => setTimeout(fn, ms));

  const iv = setInterval(() => {
    if (document.getElementById('pageCake').style.display === 'none') { clearInterval(iv); return; }
    launchBalloon();
  }, 1800);
}

// ══════════════════════════════════
//  START OVERLAY
// ══════════════════════════════════
document.getElementById('startBtn').addEventListener('click', () => {
  initAudio();
  const overlay = document.getElementById('startOverlay');
  overlay.classList.add('dissolve');
  setTimeout(() => {
    overlay.style.display = 'none';
    initStars('starsCanvas');
    runCakeSequence();
  }, 800);
});

// Dev shortcut: ?page=gallery skips straight to gallery
if (new URLSearchParams(location.search).get('page') === 'gallery') {
  document.getElementById('startOverlay').style.display = 'none';
  document.getElementById('pageCake').style.display = 'none';
  document.getElementById('pageGallery').classList.add('active');
  initParticleField('particleCanvas3', { count: 50, lite: true });
  initGallery();
  startAmbientPiano();
}

// ══════════════════════════════════
//  PAGE TRANSITION — CAKE → GALLERY
// ══════════════════════════════════
nextBtn.addEventListener('click', () => {
  // Fade out birthday audio
  fadeOutMusic();

  const pageCake = document.getElementById('pageCake');
  const pageGal = document.getElementById('pageGallery');

  pageCake.style.transition = 'opacity 0.8s ease';
  pageCake.style.opacity = '0';

  setTimeout(() => {
    pageCake.style.display = 'none';
    pageGal.classList.add('active');
    initParticleField('particleCanvas3', { count: 50, lite: true });
    initGallery();
    startAmbientPiano();
  }, 800);
});

// ══════════════════════════════════
//  GALLERY BACK BUTTON → CAKE
// ══════════════════════════════════
document.getElementById('galleryBack').addEventListener('click', () => {
  const pageGal = document.getElementById('pageGallery');
  const pageCake = document.getElementById('pageCake');

  stopAmbientPiano();
  if (galleryRAF) { cancelAnimationFrame(galleryRAF); galleryRAF = null; }
  if (gyroHandler) { window.removeEventListener('deviceorientation', gyroHandler); gyroHandler = null; }
  if (galAbort) { galAbort.abort(); galAbort = null; }
  if (galRenderer) {
    const c = document.getElementById('galleryRenderer');
    if (c && galRenderer.domElement.parentNode === c) c.removeChild(galRenderer.domElement);
    galRenderer.dispose();
    galRenderer = null;
  }
  galScene3 = null;
  galCamera = null;

  pageGal.style.transition = 'opacity 0.8s ease';
  pageGal.style.opacity = '0';

  setTimeout(() => {
    pageGal.classList.remove('active');
    pageGal.style.opacity = '';
    pageGal.style.transition = '';
    pageCake.style.display = '';
    pageCake.style.opacity = '1';
    // Fade birthday audio back in
    if (birthdayAudio) {
      birthdayAudio.volume = 0;
      birthdayAudio.play().catch(() => {});
      let v = 0;
      const fi = setInterval(() => {
        v += 0.03;
        if (v >= 0.8) { v = 0.8; clearInterval(fi); }
        birthdayAudio.volume = v;
      }, 50);
    }
  }, 800);
});

// ══════════════════════════════════
//  3D GALLERY — THREE.JS ORBITING PHOTOS
// ══════════════════════════════════
let galleryRAF = null;
let galAbort = null;
let gyroHandler = null;
let galRenderer = null;
let galScene3 = null;
let galCamera = null;

function initGallery() {
  const container = document.getElementById('galleryRenderer');

  // Clean up previous
  if (galAbort) galAbort.abort();
  galAbort = new AbortController();
  const sig = { signal: galAbort.signal };
  if (galRenderer) { container.removeChild(galRenderer.domElement); galRenderer.dispose(); }

  // ── Scene setup ──
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x06060e);
  galScene3 = scene;

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 0, 0);
  galCamera = camera;

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.appendChild(renderer.domElement);
  galRenderer = renderer;

  // Lights
  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);
  const point1 = new THREE.PointLight(0xb44dff, 0.6, 20);
  point1.position.set(3, 3, 3);
  scene.add(point1);
  const point2 = new THREE.PointLight(0xff2d95, 0.4, 20);
  point2.position.set(-3, -2, -3);
  scene.add(point2);

  // ── Neon colors for borders ──
  const neonCSS = ['#ff2d95','#b44dff','#00d4ff','#ffb800','#00ff88','#e879f9','#00fff7'];

  // ── Create neon frame texture on canvas ──
  function makeNeonFrameTexture(color) {
    const w = 256, h = 360;
    const cv = document.createElement('canvas');
    cv.width = w; cv.height = h;
    const cx = cv.getContext('2d');

    // Outer glow pass
    cx.shadowColor = color;
    cx.shadowBlur = 25;
    cx.strokeStyle = color;
    cx.lineWidth = 4;
    cx.globalAlpha = 0.5;
    roundRect(cx, 14, 14, w - 28, h - 28, 18);
    cx.stroke();

    // Bright core border
    cx.shadowBlur = 12;
    cx.lineWidth = 2;
    cx.globalAlpha = 1.0;
    roundRect(cx, 14, 14, w - 28, h - 28, 18);
    cx.stroke();

    // Inner subtle glow
    cx.shadowBlur = 8;
    cx.lineWidth = 1;
    cx.globalAlpha = 0.3;
    roundRect(cx, 20, 20, w - 40, h - 40, 14);
    cx.stroke();

    // Corner flares — bright dots at corners
    cx.shadowBlur = 15;
    cx.globalAlpha = 0.9;
    cx.fillStyle = '#fff';
    const corners = [[18,18],[w-18,18],[18,h-18],[w-18,h-18]];
    for (const [cx2,cy2] of corners) {
      cx.beginPath();
      cx.arc(cx2, cy2, 3, 0, Math.PI * 2);
      cx.fill();
    }

    const tex = new THREE.CanvasTexture(cv);
    tex.needsUpdate = true;
    return tex;
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  // ── Load photo textures and create card meshes ──
  const loader = new THREE.TextureLoader();
  const orbitRadius = 5;
  const cardMeshes = [];
  const cardData = [];
  let ringAngle = 0;
  const ringSpeed = 0.0018;

  PHOTOS.forEach((src, i) => {
    const tex = loader.load(src);
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;

    // Card geometry (portrait)
    const cardGeo = new THREE.PlaneGeometry(1.2, 1.7);
    const cardMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
    const cardMesh = new THREE.Mesh(cardGeo, cardMat);

    // Neon frame — canvas-drawn glowing border
    const frameTex = makeNeonFrameTexture(neonCSS[i % neonCSS.length]);
    const frameGeo = new THREE.PlaneGeometry(1.45, 2.0);
    const frameMat = new THREE.MeshBasicMaterial({
      map: frameTex,
      transparent: true,
      opacity: 0.9,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const frameMesh = new THREE.Mesh(frameGeo, frameMat);
    frameMesh.position.z = -0.01;
    cardMesh.add(frameMesh);

    // Soft aura glow behind everything
    const auraGeo = new THREE.PlaneGeometry(2.0, 2.6);
    const neonColor = new THREE.Color(neonCSS[i % neonCSS.length]);
    const auraMat = new THREE.MeshBasicMaterial({
      color: neonColor,
      transparent: true,
      opacity: 0.08,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const auraMesh = new THREE.Mesh(auraGeo, auraMat);
    auraMesh.position.z = -0.03;
    cardMesh.add(auraMesh);

    scene.add(cardMesh);
    cardMeshes.push(cardMesh);

    // Fixed slot in the ring — cards never overlap
    const slotAngle = (i / PHOTOS.length) * Math.PI * 2;
    cardData.push({
      mesh: cardMesh,
      frame: frameMesh,
      frameMat: frameMat,
      aura: auraMesh,
      auraMat: auraMat,
      neonColor: neonColor,
      slotAngle: slotAngle,
      yBase: (Math.random() - 0.5) * 0.5,
      yAmp: 0.12 + Math.random() * 0.2,
      ySpeed: 0.6 + Math.random() * 0.8,
      yPhase: Math.random() * Math.PI * 2,
      tiltAmp: 0.08 + Math.random() * 0.1,
      tiltPhase: Math.random() * Math.PI * 2,
      photoSrc: src,
      flying: false,
      flyData: null
    });
  });

  // ── Ambient particles ──
  const particleCount = 200;
  const pGeo = new THREE.BufferGeometry();
  const pPositions = new Float32Array(particleCount * 3);
  const pColors = new Float32Array(particleCount * 3);
  const pSizes = new Float32Array(particleCount);
  const pPhases = new Float32Array(particleCount);
  const neonRGB = [
    [1, 0.18, 0.58], [0.71, 0.3, 1], [0, 0.83, 1],
    [1, 0.72, 0], [0, 1, 0.53], [0.91, 0.47, 0.98], [0, 1, 0.97]
  ];
  for (let i = 0; i < particleCount; i++) {
    pPositions[i * 3] = (Math.random() - 0.5) * 14;
    pPositions[i * 3 + 1] = (Math.random() - 0.5) * 10;
    pPositions[i * 3 + 2] = (Math.random() - 0.5) * 14;
    const c = neonRGB[Math.floor(Math.random() * neonRGB.length)];
    pColors[i * 3] = c[0];
    pColors[i * 3 + 1] = c[1];
    pColors[i * 3 + 2] = c[2];
    pSizes[i] = Math.random() * 3 + 1;
    pPhases[i] = Math.random() * Math.PI * 2;
  }
  pGeo.setAttribute('position', new THREE.BufferAttribute(pPositions, 3));
  pGeo.setAttribute('color', new THREE.BufferAttribute(pColors, 3));
  pGeo.setAttribute('size', new THREE.BufferAttribute(pSizes, 1));

  const pMat = new THREE.PointsMaterial({
    size: 0.06,
    vertexColors: true,
    transparent: true,
    opacity: 0.6,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const particleSystem = new THREE.Points(pGeo, pMat);
  scene.add(particleSystem);

  // ── Trail particles pool (for fly animation) ──
  const trailPool = [];
  const trailGeo = new THREE.SphereGeometry(0.03, 4, 4);
  for (let i = 0; i < 60; i++) {
    const c = neonRGB[Math.floor(Math.random() * neonRGB.length)];
    const tMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(c[0], c[1], c[2]),
      transparent: true, opacity: 0,
      blending: THREE.AdditiveBlending
    });
    const tMesh = new THREE.Mesh(trailGeo, tMat);
    tMesh.visible = false;
    scene.add(tMesh);
    trailPool.push({ mesh: tMesh, mat: tMat, life: 0 });
  }
  let trailIdx = 0;

  function spawnTrail(x, y, z) {
    const t = trailPool[trailIdx % trailPool.length];
    trailIdx++;
    t.mesh.position.set(
      x + (Math.random() - 0.5) * 0.3,
      y + (Math.random() - 0.5) * 0.3,
      z + (Math.random() - 0.5) * 0.3
    );
    t.mat.opacity = 0.8;
    t.mesh.visible = true;
    t.life = 1.0;
    t.mesh.scale.setScalar(1 + Math.random());
  }

  // ── Camera controls — yaw/pitch ──
  let galYaw = 0, galPitch = 0;
  let galVelX = 0, galVelY = 0;
  let galDragging = false, galLastX = 0, galLastY = 0;
  let dragStartX = 0, dragStartY = 0, dragMoved = false;

  function onStart(x, y) {
    if (flyOpen) return; // don't drag while viewing a photo
    galDragging = true;
    galLastX = x; galLastY = y;
    dragStartX = x; dragStartY = y;
    dragMoved = false;
    galVelX = 0; galVelY = 0;
  }

  function onMove(x, y) {
    if (!galDragging) return;
    const dx = x - galLastX;
    const dy = y - galLastY;
    if (Math.abs(x - dragStartX) > 15 || Math.abs(y - dragStartY) > 15) dragMoved = true;
    const sens = 0.004;
    galYaw -= dx * sens;
    galPitch += dy * sens;
    galVelX = -dx * sens;
    galVelY = dy * sens;
    galLastX = x; galLastY = y;
  }

  function onEnd() { galDragging = false; }

  document.addEventListener('mousedown', e => {
    if (!document.getElementById('pageGallery').classList.contains('active')) return;
    onStart(e.clientX, e.clientY);
  }, sig);
  document.addEventListener('mousemove', e => {
    if (!document.getElementById('pageGallery').classList.contains('active')) return;
    onMove(e.clientX, e.clientY);
  }, sig);
  document.addEventListener('mouseup', onEnd, sig);

  document.addEventListener('touchstart', e => {
    if (!document.getElementById('pageGallery').classList.contains('active')) return;
    onStart(e.touches[0].clientX, e.touches[0].clientY);
  }, { ...sig, passive: true });
  document.addEventListener('touchmove', e => {
    if (!document.getElementById('pageGallery').classList.contains('active')) return;
    if (e.cancelable) e.preventDefault();
    onMove(e.touches[0].clientX, e.touches[0].clientY);
  }, { ...sig, passive: false });
  document.addEventListener('touchend', onEnd, sig);

  // ── Gyroscope — left/right only (yaw) ──
  if (gyroHandler) { window.removeEventListener('deviceorientation', gyroHandler); gyroHandler = null; }
  let gyroBaseA = null, gyroReady = false;

  gyroHandler = function(e) {
    if (e.alpha === null) return;
    if (!gyroReady) { gyroBaseA = e.alpha; gyroReady = true; return; }
    if (galDragging) { gyroBaseA = e.alpha; return; } // re-calibrate during drag
    let dA = e.alpha - gyroBaseA;
    if (dA > 180) dA -= 360;
    if (dA < -180) dA += 360;
    const targetYaw = -dA * Math.PI / 120;
    galYaw += (targetYaw - galYaw) * 0.08;
  };

  if ('ontouchstart' in window) {
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(p => { if (p === 'granted') window.addEventListener('deviceorientation', gyroHandler); })
        .catch(() => {});
    } else {
      window.addEventListener('deviceorientation', gyroHandler);
    }
  }

  // ── Card click detection (raycasting) ──
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let flyOpen = false;
  let flyCardIdx = -1;

  function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  }

  function onClick(clientX, clientY) {
    if (dragMoved) return;

    // If a card is open, any tap/click closes it
    if (flyOpen) {
      closeCard();
      return;
    }

    mouse.x = (clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(cardMeshes, false);
    if (hits.length > 0) {
      const idx = cardMeshes.indexOf(hits[0].object);
      if (idx !== -1 && !cardData[idx].flying) openCard(idx);
    }
  }

  document.addEventListener('click', e => {
    if (!document.getElementById('pageGallery').classList.contains('active')) return;
    if (dragMoved) return;
    onClick(e.clientX, e.clientY);
  }, sig);

  // ── Fly-to-camera animation ──
  function openCard(idx) {
    flyOpen = true;
    flyCardIdx = idx;
    container.style.cursor = 'pointer';
    const cd = cardData[idx];
    cd.flying = true;

    // Target: 3 units in front of camera
    const forward = new THREE.Vector3(0, 0, -3);
    forward.applyQuaternion(camera.quaternion);
    const targetPos = camera.position.clone().add(forward);

    cd.flyData = {
      startPos: cd.mesh.position.clone(),
      targetPos: targetPos,
      startScale: cd.mesh.scale.clone(),
      targetScale: new THREE.Vector3(1.8, 1.8, 1.8),
      startTime: performance.now(),
      duration: 1800,
      returning: false
    };
  }

  function closeCard() {
    if (!flyOpen || flyCardIdx < 0) return;
    const cd = cardData[flyCardIdx];
    if (!cd.flyData) return;
    container.style.cursor = 'grab';

    // Return to current slot position in the ring (ring keeps turning)
    const currentSlot = ringAngle + cd.slotAngle;
    const returnPos = new THREE.Vector3(
      orbitRadius * Math.cos(currentSlot),
      cd.yBase,
      orbitRadius * Math.sin(currentSlot)
    );

    cd.flyData = {
      startPos: cd.mesh.position.clone(),
      targetPos: returnPos,
      startScale: cd.mesh.scale.clone(),
      targetScale: new THREE.Vector3(1, 1, 1),
      startTime: performance.now(),
      duration: 1200,
      returning: true
    };
  }

  // ── Resize handler ──
  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener('resize', onResize, sig);

  // ── Main render loop ──
  let time = 0;
  const clock = new THREE.Clock();

  function animate() {
    if (!document.getElementById('pageGallery').classList.contains('active')) return;
    galleryRAF = requestAnimationFrame(animate);
    const dt = clock.getDelta();
    time += dt;

    // Momentum when not dragging
    if (!galDragging) {
      galYaw += galVelX;
      galPitch += galVelY;
      galVelX *= 0.93;
      galVelY *= 0.93;
      if (Math.abs(galVelX) < 0.00005) galVelX = 0;
      if (Math.abs(galVelY) < 0.00005) galVelY = 0;
    }

    // Apply camera rotation (yaw/pitch only, camera stays at origin)
    camera.rotation.set(galPitch, galYaw, 0, 'YXZ');

    // Advance the ring (whole ring rotates together)
    ringAngle += ringSpeed;

    // Orbit each card
    for (const cd of cardData) {
      if (cd.flying && cd.flyData) {
        // Fly animation
        const fd = cd.flyData;
        const elapsed = performance.now() - fd.startTime;
        const raw = Math.min(elapsed / fd.duration, 1);
        const t = easeInOutCubic(raw);

        if (fd.returning) {
          // Dynamically update target to current slot position (ring keeps moving)
          const curSlot = ringAngle + cd.slotAngle;
          const slotY = cd.yBase + Math.sin(time * cd.ySpeed + cd.yPhase) * cd.yAmp;
          fd.targetPos.set(
            orbitRadius * Math.cos(curSlot),
            slotY,
            orbitRadius * Math.sin(curSlot)
          );
        }

        // Lerp position with arc
        const pos = new THREE.Vector3().lerpVectors(fd.startPos, fd.targetPos, t);
        pos.y += Math.sin(raw * Math.PI) * (fd.returning ? 0.3 : 0.6);
        cd.mesh.position.copy(pos);

        // Scale
        cd.mesh.scale.lerpVectors(fd.startScale, fd.targetScale, t);

        // Face camera
        cd.mesh.lookAt(camera.position);

        // Frame glow intensifies while flying, dims while returning
        const frameBase = 0.9;
        if (!fd.returning) {
          cd.frameMat.opacity = frameBase + t * 0.1;
          cd.auraMat.opacity = 0.08 + t * 0.2;
        } else {
          cd.frameMat.opacity = 1.0 - t * 0.1;
          cd.auraMat.opacity = 0.28 - t * 0.2;
        }

        // Spawn trail particles
        if (raw < 0.95 && Math.random() < 0.4) {
          spawnTrail(pos.x, pos.y, pos.z);
        }

        // Animation done
        if (raw >= 1) {
          if (fd.returning) {
            cd.flying = false;
            cd.flyData = null;
            cd.mesh.scale.set(1, 1, 1);
            cd.frameMat.opacity = frameBase;
            cd.auraMat.opacity = 0.08;
            flyOpen = false;
            flyCardIdx = -1;
          }
        }
      } else {
        // Normal orbit — fixed slot in the ring
        const angle = ringAngle + cd.slotAngle;
        const y = cd.yBase + Math.sin(time * cd.ySpeed + cd.yPhase) * cd.yAmp;
        const tilt = Math.sin(time * 0.6 + cd.tiltPhase) * cd.tiltAmp;

        cd.mesh.position.set(
          orbitRadius * Math.cos(angle),
          y,
          orbitRadius * Math.sin(angle)
        );
        cd.mesh.lookAt(camera.position);
        cd.mesh.rotation.z = tilt;

        // Pulsing neon frame glow
        const pulse = Math.sin(time * 1.5 + cd.yPhase) * 0.5 + 0.5;
        cd.frameMat.opacity = 0.7 + pulse * 0.3;
        cd.auraMat.opacity = 0.05 + pulse * 0.06;
      }
    }

    // If a card is open and not returning, keep it in front of camera
    if (flyOpen && flyCardIdx >= 0) {
      const cd = cardData[flyCardIdx];
      if (cd.flying && cd.flyData && !cd.flyData.returning) {
        const elapsed = performance.now() - cd.flyData.startTime;
        if (elapsed >= cd.flyData.duration) {
          const forward = new THREE.Vector3(0, 0, -3);
          forward.applyQuaternion(camera.quaternion);
          cd.mesh.position.copy(camera.position).add(forward);
          cd.mesh.lookAt(camera.position);
          cd.mesh.scale.set(1.8, 1.8, 1.8);
        }
      }
    }

    // Animate ambient particles (slow drift + twinkle)
    const positions = pGeo.attributes.position.array;
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3 + 1] += Math.sin(time * 0.3 + pPhases[i]) * 0.001;
      positions[i * 3] += Math.cos(time * 0.2 + pPhases[i]) * 0.0005;
    }
    pGeo.attributes.position.needsUpdate = true;
    pMat.opacity = 0.4 + Math.sin(time * 0.5) * 0.15;

    // Update trail particles
    for (const tp of trailPool) {
      if (tp.life > 0) {
        tp.life -= dt * 1.5;
        tp.mat.opacity = Math.max(0, tp.life * 0.8);
        tp.mesh.scale.setScalar(tp.life);
        if (tp.life <= 0) { tp.mesh.visible = false; tp.mat.opacity = 0; }
      }
    }

    renderer.render(scene, camera);
  }

  animate();
}

// ══════════════════════════════════
//  GENERATIVE AMBIENT PIANO
// ══════════════════════════════════
let pianoCtx = null;
let pianoGain = null;
let pianoTimer = null;
let pianoConvolver = null;

function createReverb(ctx) {
  const convolver = ctx.createConvolver();
  const rate = ctx.sampleRate;
  const length = rate * 3;
  const impulse = ctx.createBuffer(2, length, rate);
  for (let ch = 0; ch < 2; ch++) {
    const data = impulse.getChannelData(ch);
    for (let i = 0; i < length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
    }
  }
  convolver.buffer = impulse;
  return convolver;
}

function startAmbientPiano() {
  pianoCtx = new (window.AudioContext || window.webkitAudioContext)();
  pianoGain = pianoCtx.createGain();
  pianoGain.gain.value = 0.25;

  pianoConvolver = createReverb(pianoCtx);
  const wetGain = pianoCtx.createGain();
  wetGain.gain.value = 0.6;
  const dryGain = pianoCtx.createGain();
  dryGain.gain.value = 0.4;

  pianoGain.connect(dryGain);
  dryGain.connect(pianoCtx.destination);
  pianoGain.connect(pianoConvolver);
  pianoConvolver.connect(wetGain);
  wetGain.connect(pianoCtx.destination);

  // Pentatonic notes across octaves (dreamy, no dissonance)
  const notes = [
    261.63, 293.66, 329.63, 392.00, 440.00,  // C4 D4 E4 G4 A4
    523.25, 587.33, 659.25, 783.99, 880.00,  // C5 D5 E5 G5 A5
    130.81, 146.83, 164.81, 196.00, 220.00   // C3 D3 E3 G3 A3
  ];

  let lastNote = -1;

  function playNote() {
    if (!pianoCtx || pianoCtx.state === 'closed') return;

    // Pick a note (avoid repeating the same one)
    let idx;
    do { idx = Math.floor(Math.random() * notes.length); } while (idx === lastNote);
    lastNote = idx;
    const freq = notes[idx];
    const t = pianoCtx.currentTime;

    // Main tone (sine — warm piano fundamental)
    const osc = pianoCtx.createOscillator();
    const g = pianoCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0.3, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 3.5);
    osc.connect(g);
    g.connect(pianoGain);
    osc.start(t);
    osc.stop(t + 4);

    // Soft overtone (triangle, octave up)
    const osc2 = pianoCtx.createOscillator();
    const g2 = pianoCtx.createGain();
    osc2.type = 'triangle';
    osc2.frequency.value = freq * 2;
    g2.gain.setValueAtTime(0.06, t);
    g2.gain.exponentialRampToValueAtTime(0.001, t + 2.5);
    osc2.connect(g2);
    g2.connect(pianoGain);
    osc2.start(t);
    osc2.stop(t + 3);

    // Sometimes play a chord (30% chance)
    if (Math.random() < 0.3) {
      const chordNote = notes[(idx + 2) % notes.length];
      const osc3 = pianoCtx.createOscillator();
      const g3 = pianoCtx.createGain();
      osc3.type = 'sine';
      osc3.frequency.value = chordNote;
      g3.gain.setValueAtTime(0.15, t + 0.1);
      g3.gain.exponentialRampToValueAtTime(0.001, t + 3);
      osc3.connect(g3);
      g3.connect(pianoGain);
      osc3.start(t + 0.1);
      osc3.stop(t + 3.5);
    }

    // Schedule next note (1.2 - 2.8 seconds)
    const next = 1200 + Math.random() * 1600;
    pianoTimer = setTimeout(playNote, next);
  }

  playNote();
}

function stopAmbientPiano() {
  if (pianoTimer) { clearTimeout(pianoTimer); pianoTimer = null; }
  if (pianoCtx && pianoCtx.state !== 'closed') {
    if (pianoGain) {
      pianoGain.gain.linearRampToValueAtTime(0, pianoCtx.currentTime + 1.5);
    }
    setTimeout(() => {
      if (pianoCtx && pianoCtx.state !== 'closed') pianoCtx.close().catch(() => {});
      pianoCtx = null;
    }, 2000);
  }
}
  </script>
</body>
</html>
